import os
import json
import argparse
import logging
from pathlib import Path
from typing import Dict, List, Any, Optional

import openai
from dotenv import load_dotenv
from e2b import Sandbox

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("react_gpt_engineer")

load_dotenv()


class ReactGPTEngineer:
    """
    ReactGPTEngineer generates simple React applications based on detailed prompts
    and tests them in an E2B sandbox environment.
    """

    # Predefined folder structure for React apps
    FOLDER_STRUCTURE = {
        "src": {
            "components": {},
            "hooks": {},
            "utils": {},
            "styles": {},
            "assets": {},
        },
        "public": {},
        "tests": {},
    }

    # Predefined sections for components
    COMPONENT_TEMPLATE = """
import React from 'react';
import './styles.css';

// SECTION: Component Props Interface
interface {name}Props {{
  // Define props here
{props}
}}

// SECTION: Component Definition
const {name}: React.FC<{name}Props> = ({{{params}}}) => {{
  // SECTION: Hooks and State
{hooks}

  // SECTION: Helper Functions
{helpers}

  // SECTION: Render Logic
  return (
    <div className="{name.toLowerCase()}-container">
{jsx}
    </div>
  );
}};

export default {name};
"""

    def __init__(
            self,
            openai_api_key: Optional[str] = None,
            model: str = "gpt-4o",
            temperature: float = 0.7,
            output_dir: str = "./react-app",
    ):
        """
        Initialize the React GPT Engineer.

        Args:
            openai_api_key: OpenAI API key (defaults to os.environ["OPENAI_API_KEY"])
            model: OpenAI model to use
            temperature: Temperature for generation (higher = more creative)
            output_dir: Directory to store generated code
        """
        self.openai_api_key = openai_api_key or os.environ.get("OPENAI_API_KEY")
        if not self.openai_api_key:
            raise ValueError("OpenAI API key must be provided or set as OPENAI_API_KEY environment variable")

        self.client = openai.OpenAI(api_key=self.openai_api_key)
        self.model = model
        self.temperature = temperature
        self.output_dir = Path(output_dir)

    def create_folder_structure(self):
        """Create the predefined folder structure for the React app"""
        logger.info(f"Creating folder structure in {self.output_dir}...")

        def create_nested_dirs(base_path, structure):
            for dir_name, sub_dirs in structure.items():
                dir_path = base_path / dir_name
                dir_path.mkdir(exist_ok=True, parents=True)

                if isinstance(sub_dirs, dict) and sub_dirs:
                    create_nested_dirs(dir_path, sub_dirs)

        self.output_dir.mkdir(exist_ok=True, parents=True)
        create_nested_dirs(self.output_dir, self.FOLDER_STRUCTURE)

        # Create basic package.json, README.md and .gitignore
        with open(self.output_dir / "package.json", "w") as f:
            json.dump({
                "name": self.output_dir.name,
                "version": "0.1.0",
                "private": True,
                "dependencies": {
                    "react": "^18.2.0",
                    "react-dom": "^18.2.0",
                    "react-scripts": "5.0.1",
                    "typescript": "^4.9.5"
                },
                "scripts": {
                    "start": "react-scripts start",
                    "build": "react-scripts build",
                    "test": "react-scripts test",
                    "eject": "react-scripts eject"
                },
                "eslintConfig": {
                    "extends": ["react-app", "react-app/jest"]
                },
                "browserslist": {
                    "production": [">0.2%", "not dead", "not op_mini all"],
                    "development": ["last 1 chrome version", "last 1 firefox version", "last 1 safari version"]
                }
            }, f, indent=2)

        with open(self.output_dir / "README.md", "w") as f:
            f.write(f"# {self.output_dir.name}\n\nA simple React application generated by ReactGPTEngineer.\n")

        with open(self.output_dir / ".gitignore", "w") as f:
            f.write("node_modules\n.env\nbuild\n.DS_Store\n")

    def generate_app(self, prompt: str) -> Dict[str, str]:
        """
        Generate a simple React application based on the prompt.

        Args:
            prompt: Detailed description of the React app to build

        Returns:
            Dictionary mapping file paths to code content
        """
        logger.info("Generating React components based on the prompt...")

        system_message = """
        You are ReactGPTEngineer, an expert React developer. Your task is to create a simple React application based on the user's requirements.

        Follow these guidelines:
        1. Create ONLY simple React components with clean, minimal code
        2. Follow the predefined folder structure:
           - src/
             - components/
             - hooks/
             - utils/
             - styles/
             - assets/
           - public/
           - tests/
        3. Each component should have clearly defined sections:
           - Component Props Interface
           - Component Definition
           - Hooks and State
           - Helper Functions
           - Render Logic (JSX)
        4. Use TypeScript for type safety
        5. Keep the application simple and focused on core functionality
        6. Include basic CSS in separate files
        7. Create a simple App.tsx file that imports and uses the components
        8. Respond in JSON format with the following structure:
           {
               "files": [
                   {"path": "src/components/Component.tsx", "content": "// Code here"},
                   {"path": "src/styles/styles.css", "content": "/* CSS here */"},
                   {"path": "src/App.tsx", "content": "// App code here"}
               ],
               "description": "Brief description of what the app does"
           }

        DO NOT include complex state management libraries, routing, or advanced features unless specifically requested.
        Keep everything as simple as possible while fulfilling the requirements.
        """

        try:
            response = self.client.chat.completions.create(
                model=self.model,
                temperature=self.temperature,
                response_format={"type": "json_object"},
                messages=[
                    {"role": "system", "content": system_message},
                    {"role": "user", "content": prompt}
                ]
            )

            response_content = response.choices[0].message.content
            response_json = json.loads(response_content)

            # Convert to dictionary mapping paths to content
            files_dict = {}
            for file_info in response_json.get("files", []):
                files_dict[file_info["path"]] = file_info["content"]

            # Store description for README
            if "description" in response_json:
                files_dict["description"] = response_json["description"]

            return files_dict

        except Exception as e:
            logger.error(f"Error generating React app: {e}")
            raise

    def save_app(self, components: Dict[str, str]) -> str:
        """
        Save the generated React app to the output directory.

        Args:
            components: Dictionary mapping file paths to code content

        Returns:
            Path to the output directory
        """
        logger.info(f"Saving generated React app to {self.output_dir}...")

        # Create folder structure first
        self.create_folder_structure()

        # Update README with app description if available
        if "description" in components:
            with open(self.output_dir / "README.md", "w") as f:
                f.write(f"# {self.output_dir.name}\n\n{components['description']}\n")
            del components["description"]

        # Save all generated files
        for file_path, content in components.items():
            full_path = self.output_dir / file_path
            full_path.parent.mkdir(exist_ok=True, parents=True)

            with open(full_path, "w") as f:
                f.write(content)

        return str(self.output_dir)

    def test_in_sandbox(self, timeout: int = 60) -> dict:
        """
        Test the generated React app in an E2B sandbox.

        Args:
            timeout: Maximum time (seconds) to wait for tests to complete

        Returns:
            Test results dictionary
        """
        logger.info("Setting up E2B sandbox for testing...")

        # Create a new sandbox instance
        sandbox = Sandbox()
        try:
            # Upload the generated files to the sandbox
            sandbox.upload_dir(local_path=str(self.output_dir), remote_path="/app")

            # Run npm install
            logger.info("Installing dependencies in sandbox...")
            install_process = sandbox.process.start("cd /app && npm install")
            install_stdout, install_stderr = install_process.wait(timeout=timeout)

            if install_process.exit_code != 0:
                return {
                    "success": False,
                    "stage": "npm install",
                    "stdout": install_stdout,
                    "stderr": install_stderr
                }

            # Try building the app
            logger.info("Building the React app...")
            build_process = sandbox.process.start("cd /app && npm run build")
            build_stdout, build_stderr = build_process.wait(timeout=timeout)

            build_success = build_process.exit_code == 0

            return {
                "success": build_success,
                "stage": "npm build",
                "stdout": build_stdout,
                "stderr": build_stderr,
                "exit_code": build_process.exit_code
            }

        except Exception as e:
            logger.error(f"Error during sandbox testing: {e}")
            return {"success": False, "error": str(e)}

        finally:
            # Clean up the sandbox
            sandbox.kill()

    def run(self, prompt: str):
        """
        Generate a React app based on prompt and test it in the sandbox.

        Args:
            prompt: Detailed description of the React app to build

        Returns:
            Dictionary containing app files and test results
        """
        # Generate React app
        app_files = self.generate_app(prompt)

        # Save app to disk
        output_path = self.save_app(app_files)

        # Test app in sandbox
        test_results = self.test_in_sandbox()

        result = {
            "files": app_files,
            "output_path": output_path,
            "test_results": test_results
        }

        if test_results["success"]:
            logger.info("✅ React app built successfully!")
        else:
            logger.warning("❌ React app build failed. Check the test results for details.")

        return result


def main():
    parser = argparse.ArgumentParser(description="React GPT Engineer")
    parser.add_argument("--prompt", type=str, help="Detailed prompt describing the React app to build")
    parser.add_argument("--prompt-file", type=str, help="Path to file containing the detailed prompt")
    parser.add_argument("--model", type=str, default="gpt-4o", help="OpenAI model to use")
    parser.add_argument("--temperature", type=float, default=0.7, help="Temperature for generation")
    parser.add_argument("--output-dir", type=str, default="./react-app", help="Directory to store generated React app")

    args = parser.parse_args()

    # Get prompt from either command line or file
    if args.prompt:
        prompt = args.prompt
    elif args.prompt_file:
        with open(args.prompt_file, "r") as f:
            prompt = f.read()
    else:
        parser.error("Either --prompt or --prompt-file must be provided")

    # Initialize and run React GPT Engineer
    engineer = ReactGPTEngineer(
        model=args.model,
        temperature=args.temperature,
        output_dir=args.output_dir
    )

    result = engineer.run(prompt)

    # Save the result to a JSON file
    result_path = Path(args.output_dir) / "generation_result.json"
    with open(result_path, "w") as f:
        # Format the result for better JSON output
        result_json = {
            "output_path": result["output_path"],
            "test_results": result["test_results"],
            "files": [{"path": k, "content": v} for k, v in result["files"].items()]
        }
        json.dump(result_json, f, indent=2)

    logger.info(f"Results saved to {result_path}")


if __name__ == "__main__":
    main()